// The first few lines with the include statements are mostly self explanatory. 
// We need to include <verilated.h> and <verilated_vcd_c.h> that come with the 
// Verilator installation to access common Verilator routines and write waveforms 
// to a VCD (value change dump) file.
// This line includes the Verilated header file for the module Vand_gate. 
// The .h file is generated by Verilator based on the SystemVerilog source file containing the and_gate module. 
//It provides the necessary C++ class declaration to interact with the SystemVerilog design in your testbench.
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Vand_gate.h"

//#define max_time is used to assigned the maximum simulation time to the variable Max_time
//We use the sim_time variable to track when to finish the simulation.
#define Max_time 20
vluint64_t sim_time = 0;
//argc and argv are used to take an argument from user from command line
//Just like you type command
// cd project
// Here project is the argument to the command
int main(int argc, char** argv, char** env){
// The line Vand_gate *dut = new Vand_gate; instantiates our converted and_gate module. 
// The next four lines set up the waveform dumping. Notably, we create an m_trace obje down the device under test.
    Vand_gate *dut = new Vand_gate;
//Verilated::traceEverOn(true) in C++ code is likely related to the Verilator tool, which is used to convert SystemVerilog code into C++ for simulation.
    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace,0);
    m_trace->open("waveform.vcd");
//This is while loop which will perform simulation till < Max_time 
    while(sim_time<Max_time)
    {
//assigned values to the inputs
// The call dut->eval(); evaluates all the signals in our and_gate module, and m_trace->dump(sim_time); writes all 
// the traced signal values into our waveform dump file. 
//sim_time++ to increase the sim_time for the next simulations
        dut -> a_i = 0; 
        dut -> b_i = 0;
        dut -> eval();
        m_trace->dump(sim_time);
        sim_time++;

        dut -> a_i = 0;
        dut -> b_i = 1;
        dut -> eval();
        m_trace->dump(sim_time);
        sim_time++;    
        
        dut -> a_i = 1;
        dut -> b_i = 0;
        dut -> eval();
        m_trace->dump(sim_time);
        sim_time++;    

        dut -> a_i = 1;
        dut -> b_i = 1;
        dut -> eval();
        m_trace->dump(sim_time);
        sim_time++;    
    }
// These lines of code perform necessary cleanup tasks at the end of the simulation, including closing the VCD trace file,                                 
// deleting the Verilated model instance, and exiting the simulation process.    
    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);

}
//Dynamic object c++ support two operators new and delete to perform memory allocation and de-allocation 
//These types of objects are called dynamic objects 
// new VerilatedVcdC dynamic object creation
//delete dut Delete object dynamically 